# Learning Python (Mark Lutz, 6th ed.) — Detailed Table of Contents

- **Preface** (p. xxxi)
- **Part I. Getting Started**
  - **1. A Python Q&A Session** (p. 3)
    - Why Do People Use Python? (p. 3)
      - Software Quality (p. 4)
      - Developer Productivity (p. 5)
    - Is Python a “Scripting Language”? (p. 5)
    - OK, but What’s the Downside? (p. 6)
    - Who Uses Python Today? (p. 7)
    - What Can I Do with Python? (p. 8)
      - Systems Programming (p. 8)
      - GUIs and UIs (p. 8)
      - Internet and Web Scripting (p. 8)
      - Component Integration (p. 9)
      - Database Access (p. 9)
      - Rapid Prototyping (p. 9)
      - Numeric and Scientific Programming (p. 10)
      - And More: AI, Games, Images, QA, Excel, Apps… (p. 10)
    - What Are Python’s Technical Strengths? (p. 10)
      - It’s Object-Oriented and Functional (p. 11)
      - It’s Free and Open (p. 11)
      - It’s Portable (p. 11)
      - It’s Powerful (p. 12)
      - It’s Mixable (p. 13)
      - It’s Relatively Easy to Use (p. 13)
      - It’s Relatively Easy to Learn (p. 13)
    - Chapter Summary (p. 14)
    - Test Your Knowledge: Quiz (p. 14)
    - Test Your Knowledge: Answers (p. 14)
  - **2. How Python Runs Programs** (p. 17)
    - Introducing the Python Interpreter (p. 17)
    - Program Execution (p. 18)
      - The Programmer’s View (p. 18)
      - Python’s View (p. 18)
    - Execution-Model Variations (p. 21)
      - Python Implementation Alternatives (p. 22)
      - Standalone Executables (p. 24)
      - Future Possibilities (p. 25)
    - Chapter Summary (p. 25)
    - Test Your Knowledge: Quiz (p. 25)
    - Test Your Knowledge: Answers (p. 26)
  - **3. How You Run Programs** (p. 27)
    - Installing Python (p. 27)
    - Interactive Code (p. 28)
      - Starting an Interactive REPL (p. 28)
      - Where to Run: Code Folders (p. 29)
      - What Not to Type: Prompts and Comments (p. 30)
      - Other Python REPLs (p. 30)
      - Running Code Interactively (p. 31)
      - Why the Interactive Prompt? (p. 32)
    - Program Files (p. 34)
      - A First Script (p. 34)
      - Running Files with Command Lines (p. 35)
      - Command-Line Usage Variations (p. 36)
    - Other Ways to Run Files (p. 37)
      - Clicking and Tapping File Icons (p. 37)
      - The IDLE Graphical User Interface (p. 38)
      - Other IDEs for Python (p. 39)
      - Smartphone Apps (p. 39)
      - WebAssembly for Browsers (p. 40)
      - Jupyter Notebooks for Science (p. 40)
      - Ahead-of-Time Compilers for Speed (p. 40)
      - Running Code in Code (p. 41)
      - Other Launch Options (p. 45)
    - Which Option Should I Use? (p. 46)
    - Chapter Summary (p. 46)
    - Test Your Knowledge: Quiz (p. 46)
    - Test Your Knowledge: Answers (p. 47)
  - Test Your Knowledge: Part I Exercises (p. 48)
- **Part II. Objects and Operations**
  - **4. Introducing Python Objects** (p. 53)
    - The Python Conceptual Hierarchy (p. 53)
    - Why Use Built-in Objects? (p. 54)
    - Python’s Core Object Types (p. 55)
    - Numbers (p. 56)
    - Strings (p. 57)
      - Sequence Operations (p. 58)
      - Immutability (p. 59)
      - Type-Specific Methods (p. 60)
      - Getting Help (p. 62)
      - Other Ways to Code Strings (p. 63)
      - Unicode Strings (p. 64)
    - Lists (p. 65)
      - Sequence Operations (p. 65)
      - Type-Specific Operations (p. 65)
      - Bounds Checking (p. 66)
      - Nesting (p. 66)
      - Comprehensions (p. 67)
    - Dictionaries (p. 69)
      - Mapping Operations (p. 69)
      - Nesting Revisited (p. 70)
      - Missing Keys: if Tests (p. 71)
      - Item Iteration: for Loops (p. 73)
    - Tuples (p. 74)
      - Why Tuples? (p. 75)
    - Files (p. 75)
      - Unicode and Byte Files (p. 76)
      - Other File-Like Tools (p. 77)
    - Other Object Types (p. 77)
      - Sets (p. 77)
      - Booleans and None (p. 78)
      - Types (p. 78)
      - Type Hinting (p. 79)
      - User-Defined Objects (p. 80)
      - And Everything Else (p. 80)
    - Chapter Summary (p. 81)
    - Test Your Knowledge: Quiz (p. 81)
    - Test Your Knowledge: Answers (p. 81)
  - **5. Numbers and Expressions** (p. 83)
    - Numeric Object Basics (p. 83)
      - Numeric Literals (p. 84)
    - Built-in Numeric Tools (p. 85)
    - Python Expression Operators (p. 85)
      - Mixed Operators: Precedence (p. 87)
      - Parentheses Group Subexpressions (p. 88)
      - Mixed Types Are Converted Up (p. 88)
      - Preview: Operator Overloading and Polymorphism (p. 89)
    - Numbers in Action (p. 89)
      - Variables and Basic Expressions (p. 89)
      - Numeric Display Formats (p. 91)
      - Comparison Operators (p. 92)
      - Division Operators (p. 94)
      - Integer Precision (p. 96)
      - Complex Numbers (p. 96)
      - Hex, Octal, and Binary (p. 96)
      - Bitwise Operations (p. 98)
      - Underscore Separators in Numbers (p. 99)
      - Other Built-in Numeric Tools (p. 101)
    - Other Numeric Objects (p. 103)
      - Decimal Objects (p. 103)
      - Fraction Objects (p. 104)
      - Set Objects (p. 106)
      - Boolean Objects (p. 112)
    - Numeric Extensions (p. 113)
    - Chapter Summary (p. 113)
    - Test Your Knowledge: Quiz (p. 113)
    - Test Your Knowledge: Answers (p. 114)
  - **6. The Dynamic Typing Interlude** (p. 115)
    - The Case of the Missing Declaration Statements (p. 115)
      - Variables, Objects, and References (p. 116)
      - Types Live with Objects, Not Variables (p. 118)
      - Objects Are Garbage-Collected (p. 118)
    - Shared References (p. 120)
      - Shared References and In-Place Changes (p. 121)
      - Shared References and Equality (p. 123)
    - Dynamic Typing Is Everywhere (p. 124)
    - Type Hinting: Optional, Unused, and Why? (p. 125)
    - Chapter Summary (p. 126)
    - Test Your Knowledge: Quiz (p. 126)
    - Test Your Knowledge: Answers (p. 127)
  - **7. String Fundamentals** (p. 129)
    - String Object Basics (p. 129)
    - String Literals (p. 131)
      - Single and Double Quotes Are the Same (p. 131)
      - Escape Sequences Are Special Characters (p. 132)
      - Raw Strings Suppress Escapes (p. 136)
      - Triple Quotes and Multiline Strings (p. 137)
      - Strings in Action (p. 138)
        - Basic Operations (p. 138)
        - Indexing and Slicing (p. 140)
        - String Conversion Tools (p. 143)
        - “Changing” Strings Part 1: Sequence Operations (p. 145)
      - String Methods (p. 146)
        - Method Call Syntax (p. 146)
        - All String Methods (Today) (p. 147)
        - “Changing” Strings, Part 2: String Methods (p. 148)
        - More String Methods: Parsing Text (p. 150)
        - Other Common String Methods (p. 151)
      - String Formatting: The Triathlon (p. 151)
        - String-Formatting Options (p. 152)
        - The String-Formatting Expression (p. 153)
        - The String-Formatting Method (p. 157)
        - The F-String Formatting Literal (p. 162)
        - And the Winner Is… (p. 167)
      - General Type Categories (p. 168)
        - Types Share Operation Sets by Categories (p. 168)
        - Mutable Types Can Be Changed in Place (p. 169)
      - Chapter Summary (p. 170)
      - Test Your Knowledge: Quiz (p. 170)
      - Test Your Knowledge: Answers (p. 170)
  - **8. Lists and Dictionaries** (p. 173)
    - Lists (p. 173)
    - Lists in Action (p. 175)
      - Basic List Operations (p. 175)
      - Indexing and Slicing (p. 176)
      - Changing Lists in Place (p. 177)
      - More List Methods (p. 180)
      - Iteration, Comprehensions, and Unpacking (p. 182)
      - Other List Operations (p. 184)
    - Dictionaries (p. 184)
    - Dictionaries in Action (p. 186)
      - Basic Dictionary Operations (p. 187)
      - Changing Dictionaries in Place (p. 187)
      - More Dictionary Methods (p. 188)
      - Other Dictionary Makers (p. 189)
      - Dictionary Comprehensions (p. 191)
    - Key Insertion Ordering (p. 192)
    - Dictionary “Union” Operator (p. 193)
    - Intermission: Books Database (p. 194)
    - Dictionary Usage Tips (p. 196)
    - Chapter Summary (p. 203)
    - Test Your Knowledge: Quiz (p. 203)
    - Test Your Knowledge: Answers (p. 203)
  - **9. Tuples, Files, and Everything Else** (p. 207)
    - Tuples (p. 207)
      - Tuples in Action (p. 209)
      - Why Lists and Tuples? (p. 211)
      - Records Revisited: Named Tuples (p. 212)
    - Files (p. 213)
      - Opening Files (p. 214)
      - Using Files (p. 214)
      - Files in Action (p. 216)
      - Text and Binary Files: The Short Story (p. 217)
      - Storing Objects with Conversions (p. 218)
      - Storing Objects with pickle (p. 220)
      - Storing Objects with JSON (p. 221)
      - Storing Objects with Other Tools (p. 222)
      - File Context Managers (p. 223)
      - Other File Tools (p. 223)
    - Core Types Review and Summary (p. 224)
      - Object Flexibility (p. 225)
      - References Versus Copies (p. 226)
      - Comparisons, Equality, and Truth (p. 228)
      - The Meaning of True and False in Python (p. 231)
      - Python’s Type Hierarchies (p. 233)
      - Type Objects (p. 233)
    - Other Types in Python (p. 234)
    - Built-in Type Gotchas (p. 235)
      - Assignment Creates References, Not Copies (p. 235)
      - Repetition Adds One Level Deep (p. 236)
      - Beware of Cyclic Data Structures (p. 237)
      - Immutable Types Can’t Be Changed in Place (p. 237)
    - Chapter Summary (p. 237)
    - Test Your Knowledge: Quiz (p. 238)
    - Test Your Knowledge: Answers (p. 238)
  - Test Your Knowledge: Part II Exercises (p. 239)
- **Part III. Statements and Syntax**
  - **10. Introducing Python Statements** (p. 245)
    - The Python Conceptual Hierarchy Revisited (p. 245)
    - Python’s Statements (p. 246)
    - A Tale of Two ifs (p. 248)
      - What Python Adds (p. 248)
      - What Python Removes (p. 248)
      - Why Indentation Syntax? (p. 250)
      - A Few Special Cases (p. 252)
    - A Quick Example: Interactive Loops (p. 254)
      - A Simple Interactive Loop (p. 254)
      - Doing Math on User Inputs (p. 255)
      - Handling Errors by Testing Inputs (p. 256)
      - Handling Errors with try Statements (p. 257)
      - Supporting Floating-Point Numbers (p. 258)
      - Nesting Code Three Levels Deep (p. 259)
    - Chapter Summary (p. 259)
    - Test Your Knowledge: Quiz (p. 260)
    - Test Your Knowledge: Answers (p. 260)
  - **11. Assignments, Expressions, and Prints** (p. 261)
    - Assignments (p. 261)
      - Assignment Syntax Forms (p. 262)
      - Basic Assignments (p. 263)
      - Sequence Assignments (p. 264)
      - Extended-Unpacking Assignments (p. 266)
      - Multiple-Target Assignments (p. 271)
      - Augmented Assignments (p. 272)
      - Named Assignment Expressions (p. 274)
      - Variable Name Rules (p. 277)
    - Expression Statements (p. 280)
      - Expression Statements and In-Place Changes (p. 281)
    - Print Operations (p. 282)
      - The print Function (p. 282)
      - Print Stream Redirection (p. 285)
    - Chapter Summary (p. 288)
    - Test Your Knowledge: Quiz (p. 288)
    - Test Your Knowledge: Answers (p. 288)
  - **12. if and match Selections** (p. 291)
    - if Statements (p. 291)
      - General Format (p. 291)
      - Basic Examples (p. 292)
    - Multiple-Choice Selections (p. 293)
    - match Statements (p. 295)
      - Basic match Usage (p. 295)
      - Advanced match Usage (p. 297)
    - Python Syntax Revisited (p. 299)
      - Block Delimiters: Indentation Rules (p. 300)
      - Statement Delimiters: Lines and Continuations (p. 302)
      - Special Syntax Cases in Action (p. 303)
    - Truth Values Revisited (p. 304)
    - The if/else Ternary Expression (p. 306)
    - Chapter Summary (p. 307)
    - Test Your Knowledge: Quiz (p. 307)
    - Test Your Knowledge: Answers (p. 308)
  - **13. while and for Loops** (p. 311)
    - while Loops (p. 311)
      - General Format (p. 311)
      - Examples (p. 312)
    - break, continue, pass, and the Loop else (p. 313)
      - General Loop Format (p. 313)
      - pass (p. 313)
      - continue (p. 314)
      - break (p. 315)
      - Loop else (p. 316)
    - for Loops (p. 318)
      - General Format (p. 318)
      - Examples (p. 318)
    - Loop Coding Techniques (p. 323)
      - Counter Loops: range (p. 324)
      - Sequence Scans: while, range, and for (p. 325)
      - Sequence Shufflers: range and len (p. 326)
      - Skipping Items: range and Slices (p. 327)
      - Changing Lists: range and Comprehensions (p. 327)
      - Parallel Traversals: zip (p. 328)
      - Offsets and Items: enumerate (p. 331)
    - Chapter Summary (p. 332)
    - Test Your Knowledge: Quiz (p. 332)
    - Test Your Knowledge: Answers (p. 332)
  - **14. Iterations and Comprehensions** (p. 335)
    - Iterations (p. 336)
      - The Iteration Protocol (p. 337)
      - Other Built-in Iterables (p. 342)
    - Comprehensions (p. 347)
      - List Comprehension Basics (p. 347)
      - List Comprehensions and Files (p. 348)
      - Extended List Comprehension Syntax (p. 349)
      - Comprehensions Cliff-Hanger (p. 351)
      - Iteration Tools (p. 351)
      - Other Iteration Topics (p. 355)
      - Chapter Summary (p. 355)
      - Test Your Knowledge: Quiz (p. 356)
      - Test Your Knowledge: Answers (p. 356)
  - **15. The Documentation Interlude** (p. 357)
    - Python Documentation Sources (p. 357)
      - # Comments (p. 358)
      - The dir Function (p. 358)
      - Docstrings and __doc__ (p. 360)
      - Pydoc: The help Function (p. 363)
      - Pydoc: HTML Reports (p. 366)
      - Beyond Docstrings: Sphinx (p. 370)
      - The Standard Manuals (p. 370)
      - Web Resources (p. 371)
    - Common Coding Gotchas (p. 372)
    - Chapter Summary (p. 373)
    - Test Your Knowledge: Quiz (p. 373)
    - Test Your Knowledge: Answers (p. 374)
  - Test Your Knowledge: Part III Exercises (p. 374)
- **Part IV. Functions and Generators**
  - **16. Function Basics** (p. 379)
    - Why Use Functions? (p. 380)
    - Function Coding Overview (p. 381)
      - Basic Function Tools (p. 381)
      - Advanced Function Tools (p. 382)
      - General Function Concepts (p. 382)
      - def Statements (p. 383)
      - return Statements (p. 383)
      - def Executes at Runtime (p. 384)
      - lambda Makes Anonymous Functions (p. 384)
    - A First Example: Definitions and Calls (p. 385)
      - Definition (p. 385)
      - Calls (p. 386)
      - Polymorphism in Python (p. 386)
    - A Second Example: Intersecting Sequences (p. 387)
    - Definition (p. 387)
    - Calls (p. 388)
    - Polymorphism Revisited (p. 389)
    - Segue: Local Variables (p. 389)
    - Chapter Summary (p. 390)
    - Test Your Knowledge: Quiz (p. 390)
    - Test Your Knowledge: Answers (p. 390)
  - **17. Scopes** (p. 393)
    - Python Scopes Basics (p. 393)
      - Scopes Overview (p. 394)
      - Name Resolution: The LEGB Rule (p. 396)
      - Scopes Examples (p. 398)
      - The Built-in Scope (p. 399)
    - The global Statement (p. 401)
      - Program Design: Minimize Global Variables (p. 402)
      - Program Design: Minimize Cross-File Changes (p. 404)
      - Other Ways to Access Globals (p. 405)
    - Nested Functions and Scopes (p. 406)
      - Nested Scopes Overview (p. 406)
      - Nested Scopes Examples (p. 406)
      - Closures and Factory Functions (p. 407)
      - Arbitrary Scope Nesting (p. 409)
    - The nonlocal Statement (p. 409)
      - nonlocal Basics (p. 410)
      - nonlocal in Action (p. 410)
      - nonlocal Boundary Cases (p. 411)
    - State-Retention Options (p. 412)
      - Nonlocals: Changeable, Per-Call, LEGB (p. 413)
      - Globals: Changeable but Shared (p. 413)
      - Function Attributes: Changeable, Per-Call, Explicit (p. 414)
      - Classes: Changeable, Per-Call, OOP (p. 416)
      - And the Winner Is… (p. 416)
    - Scopes and Argument Defaults (p. 416)
      - Loops Require Defaults, Not Scopes (p. 418)
    - Chapter Summary (p. 419)
    - Test Your Knowledge: Quiz (p. 420)
    - Test Your Knowledge: Answers (p. 421)
  - **18. Arguments** (p. 423)
    - Argument-Passing Basics (p. 423)
      - Arguments and Shared References (p. 424)
      - Avoiding Mutable Argument Changes (p. 426)
      - Simulating Output Parameters and Multiple Results (p. 427)
        - Special Argument-Matching Modes (p. 428)
          - Argument Matching Overview (p. 428)
          - Argument Matching Syntax (p. 429)
          - Argument Passing Details (p. 430)
          - Keyword and Default Examples (p. 431)
          - Arbitrary Arguments Examples (p. 433)
          - Keyword-Only Arguments (p. 437)
          - Positional-Only Arguments (p. 439)
        - Argument Ordering: The Gritty Details (p. 440)
          - Definition Ordering (p. 440)
          - Calls Ordering (p. 442)
        - Example: The min Wakeup Call (p. 443)
          - Full Credit (p. 443)
          - Bonus Points (p. 445)
          - The Punch Line (p. 446)
        - Example: Generalized Set Functions (p. 446)
          - Testing the Code (p. 447)
        - Example: Rolling Your Own Print (p. 448)
          - Using Keyword-Only Arguments (p. 449)
        - Chapter Summary (p. 451)
        - Test Your Knowledge: Quiz (p. 451)
        - Test Your Knowledge: Answers (p. 452)
  - **19. Function Odds and Ends** (p. 455)
    - Function Design Concepts (p. 455)
    - Recursive Functions (p. 457)
      - Summation with Recursion (p. 457)
      - Coding Alternatives (p. 458)
      - Loop Statements Versus Recursion (p. 459)
      - Handling Arbitrary Structures (p. 460)
    - Function Tools: Attributes, Annotations, Etc. (p. 464)
      - The First-Class Object Model (p. 465)
      - Function Introspection (p. 466)
      - Function Attributes (p. 467)
      - Function Annotations and Decorations (p. 468)
    - Anonymous Functions: lambda (p. 470)
      - lambda Basics (p. 471)
      - Why Use lambda? (p. 472)
      - How (Not) to Obfuscate Your Python Code (p. 473)
      - Scopes: lambdas Can Be Nested Too (p. 475)
    - Functional Programming Tools (p. 475)
      - Mapping Functions over Iterables: map (p. 476)
      - Selecting Items in Iterables: filter (p. 477)
      - Combining Items in Iterables: reduce (p. 478)
    - Chapter Summary (p. 479)
    - Test Your Knowledge: Quiz (p. 479)
    - Test Your Knowledge: Answers (p. 479)
  - **20. Comprehensions and Generations** (p. 483)
    - Comprehensions: The Final Act (p. 483)
      - List Comprehensions Review (p. 484)
      - Formal Comprehension Syntax (p. 485)
      - Example: List Comprehensions and Matrixes (p. 487)
    - Generator Functions and Expressions (p. 490)
      - Generator Functions: yield Versus return (p. 490)
      - Generator Expressions: Iterables Meet Comprehensions (p. 496)
      - Generator Functions Versus Generator Expressions (p. 500)
      - Generator Odds and Ends (p. 501)
    - Example: Shuffling Sequences (p. 506)
      - Scrambling Sequences (p. 506)
      - Permutating Sequences (p. 509)
    - Example: Emulating zip and map (p. 513)
      - Coding Your Own map (p. 514)
      - Coding Your Own zip and 2.X map (p. 515)
    - Asynchronous Functions: The Short Story (p. 517)
      - Async Basics (p. 518)
      - The Async Wrap-Up (p. 524)
    - Chapter Summary (p. 525)
    - Test Your Knowledge: Quiz (p. 525)
    - Test Your Knowledge: Answers (p. 525)
  - **21. The Benchmarking Interlude** (p. 529)
    - Benchmarking with Homegrown Tools (p. 529)
      - Timer Module: Take 1 (p. 530)
      - Timer Module: Take 2 (p. 531)
      - Timing Runner and Script (p. 533)
      - Iteration Results (p. 535)
      - More Module Mods (p. 538)
    - Benchmarking with Python’s timeit (p. 540)
      - Basic timeit Usage (p. 540)
      - Automating timeit Benchmarking (p. 544)
    - Function Gotchas (p. 549)
      - Local Names Are Detected Statically (p. 549)
      - Defaults and Mutable Objects (p. 550)
      - Functions Without returns (p. 552)
      - Miscellaneous Function Gotchas (p. 552)
    - Chapter Summary (p. 553)
    - Test Your Knowledge: Quiz (p. 553)
      - Test Your Knowledge: Answers (p. 553)
  - Test Your Knowledge: Part IV Exercises (p. 554)
- **Part V. Modules and Packages**
  - **22. Modules: The Big Picture** (p. 559)
    - Module Essentials (p. 559)
    - Why Use Modules? (p. 560)
    - Python Program Architecture (p. 560)
      - How to Structure a Program (p. 561)
      - Imports and Attributes (p. 561)
      - Standard-Library Modules (p. 563)
    - How Imports Work (p. 563)
      - Step 1: Find It (p. 564)
      - Step 2: Compile It (Maybe) (p. 564)
      - Step 3: Run It (p. 567)
    - The Module Search Path (p. 567)
      - Search-Path Components (p. 567)
      - Configuring the Search Path (p. 570)
      - The sys.path List (p. 570)
      - Module File Selection (p. 571)
      - Path Outliers: Standalones and Packages (p. 572)
    - Chapter Summary (p. 573)
    - Test Your Knowledge: Quiz (p. 573)
    - Test Your Knowledge: Answers (p. 573)
  - **23. Module Coding Basics** (p. 575)
    - Creating Modules (p. 575)
      - Module Filenames (p. 575)
      - Other Kinds of Modules (p. 576)
    - Using Modules (p. 576)
      - The import Statement (p. 576)
      - The from Statement (p. 577)
      - The from * Statement (p. 577)
      - Imports Happen Only Once (p. 578)
      - Imports Are Runtime Assignments (p. 579)
      - import and from Equivalence (p. 580)
      - Potential Pitfalls of the from Statement (p. 580)
    - Module Namespaces (p. 582)
      - How Files Generate Namespaces (p. 582)
      - Namespace Dictionaries: __dict__ (p. 583)
      - Attribute Name Qualification (p. 584)
      - Imports Versus Scopes (p. 585)
    - Namespace Nesting (p. 586)
    - Reloading Modules (p. 587)
      - reload Basics (p. 588)
      - reload Example (p. 588)
      - reload Odds and Ends (p. 590)
    - Chapter Summary (p. 590)
    - Test Your Knowledge: Quiz (p. 590)
    - Test Your Knowledge: Answers (p. 591)
  - **24. Module Packages** (p. 593)
    - Using Packages (p. 593)
      - Package Imports (p. 594)
      - Packages and the Module Search Path (p. 594)
    - Creating Packages (p. 595)
      - Basic Package Structure (p. 595)
      - Package __init__.py Files (p. 597)
      - Package __main__.py Files (p. 599)
    - Why Packages? (p. 600)
      - A Tale of Two Systems (p. 600)
    - The Roles of __init__.py Files (p. 603)
    - Package-Relative Imports (p. 604)
      - Relative and Absolute Imports (p. 604)
      - Relative-Import Rationales and Trade-Offs (p. 605)
      - Package-Relative Imports in Action (p. 605)
    - Namespace Packages (p. 609)
      - Python Import Models (p. 609)
      - Namespace-Package Rationales (p. 610)
      - The Module Search Algorithm (p. 610)
      - Namespace Packages in Action (p. 611)
    - Chapter Summary (p. 613)
    - Test Your Knowledge: Quiz (p. 614)
    - Test Your Knowledge: Answers (p. 614)
  - **25. Module Odds and Ends** (p. 617)
    - Module Design Concepts (p. 617)
    - Data Hiding in Modules (p. 618)
      - Minimizing from * Damage: _X and __all__ (p. 619)
      - Managing Attribute Access: __getattr__ and __dir__ (p. 620)
    - Enabling Language Changes: __future__ (p. 622)
    - Dual-Usage Modes: __name__ and __main__ (p. 622)
      - Example: Unit Tests with __name__ (p. 623)
    - The as Extension for import and from (p. 625)
    - Module Introspection (p. 626)
      - Example: Listing Modules with __dict__ (p. 627)
        - Importing Modules by Name String (p. 629)
          - Running Code Strings (p. 629)
          - Direct Calls: Two Options (p. 630)
          - Example: Transitive Module Reloads (p. 630)
        - Module Gotchas (p. 638)
          - Module Name Clashes: Package and Package-Relative Imports (p. 638)
          - Statement Order Matters in Top-Level Code (p. 638)
          - from Copies Names but Doesn’t Link (p. 639)
          - from * Can Obscure the Meaning of Variables (p. 640)
          - reload May Not Impact from Imports (p. 640)
          - reload, from, and Interactive Testing (p. 641)
          - Recursive from Imports May Not Work (p. 642)
        - Chapter Summary (p. 643)
        - Test Your Knowledge: Quiz (p. 643)
        - Test Your Knowledge: Answers (p. 643)
  - Test Your Knowledge: Part V Exercises (p. 644)
- **Part VI. Classes and OOP**
  - **26. OOP: The Big Picture** (p. 649)
    - Why Use Classes? (p. 649)
    - OOP from 30,000 Feet (p. 651)
      - Attribute Inheritance Search (p. 651)
      - Classes and Instances (p. 653)
      - Method Calls (p. 653)
      - Coding Class Trees (p. 654)
      - Operator Overloading (p. 656)
      - OOP Is About Code Reuse (p. 656)
    - Chapter Summary (p. 659)
    - Test Your Knowledge: Quiz (p. 659)
    - Test Your Knowledge: Answers (p. 659)
  - **27. Class Coding Basics** (p. 661)
    - Classes Generate Multiple Instance Objects (p. 661)
      - Class Objects Provide Default Behavior (p. 662)
      - Instance Objects Are Concrete Items (p. 662)
      - A First Example (p. 662)
    - Classes Are Customized by Inheritance (p. 664)
      - A Second Example (p. 665)
      - Classes Are Attributes in Modules (p. 666)
    - Classes Can Intercept Python Operators (p. 667)
      - A Third Example (p. 669)
    - The World’s Simplest Python Class (p. 671)
    - Classes: Under the Hood (p. 671)
    - Records Revisited: Classes Versus Dictionaries (p. 673)
    - Chapter Summary (p. 675)
    - Test Your Knowledge: Quiz (p. 675)
    - Test Your Knowledge: Answers (p. 676)
  - **28. A More Realistic Example** (p. 679)
    - Step 1: Making Instances (p. 679)
      - Coding Constructors (p. 680)
      - Testing as You Go (p. 681)
      - Using Code Two Ways (p. 682)
    - Step 2: Adding Behavior Methods (p. 683)
      - Coding Methods (p. 684)
    - Step 3: Operator Overloading (p. 686)
      - Providing Print Displays (p. 686)
    - Step 4: Customizing Behavior by Subclassing (p. 688)
      - Coding Subclasses (p. 688)
      - Augmenting Methods: The Bad Way (p. 689)
      - Augmenting Methods: The Good Way (p. 689)
      - Polymorphism in Action (p. 691)
      - Inherit, Customize, and Extend (p. 692)
      - OOP: The Big Idea (p. 693)
    - Step 5: Customizing Constructors, Too (p. 693)
      - OOP Is Simpler Than You May Think (p. 695)
      - Other Ways to Combine Classes: Composites (p. 695)
    - Step 6: Using Introspection Tools (p. 698)
      - Special Class Attributes (p. 699)
      - A Generic Display Tool (p. 700)
      - Instance Versus Class Attributes (p. 701)
      - Name Considerations in Tool Classes (p. 702)
      - Our Classes’ Final Form (p. 702)
    - Step 7 (Final): Storing Objects in a Database (p. 704)
      - Pickles and Shelves (p. 704)
      - Storing Objects on a shelve Database (p. 705)
      - Exploring Shelves Interactively (p. 706)
      - Updating Objects on a Shelf (p. 708)
    - Future Directions (p. 709)
    - Chapter Summary (p. 709)
    - Test Your Knowledge: Quiz (p. 710)
    - Test Your Knowledge: Answers (p. 710)
  - **29. Class Coding Details** (p. 713)
    - The class Statement (p. 713)
      - General Syntax and Usage (p. 713)
        - Example: Class Attributes (p. 714)
        - Methods (p. 716)
          - Method Example (p. 716)
          - Other Method-Call Possibilities (p. 717)
        - Inheritance (p. 718)
          - Attribute Tree Construction (p. 718)
          - Inheritance Fine Print (p. 719)
          - Specializing Inherited Methods (p. 719)
          - Class Interface Techniques (p. 721)
          - Abstract Superclasses (p. 722)
        - Namespaces: The Conclusion (p. 724)
          - Simple Names: Global Unless Assigned (p. 725)
          - Attribute Names: Object Namespaces (p. 725)
          - The “Zen” of Namespaces: Assignments Classify Names (p. 726)
          - Nested Classes: The LEGB Scopes Rule Revisited (p. 728)
          - Namespace Dictionaries: Review (p. 730)
          - Namespace Links: A Tree Climber (p. 732)
        - Documentation Strings Revisited (p. 734)
        - Classes Versus Modules (p. 735)
        - Chapter Summary (p. 736)
        - Test Your Knowledge: Quiz (p. 736)
        - Test Your Knowledge: Answers (p. 736)
  - **30. Operator Overloading** (p. 739)
    - The Basics (p. 739)
      - Constructors and Expressions: __init__ and __sub__ (p. 740)
      - Common Operator-Overloading Methods (p. 740)
    - Indexing and Slicing: __getitem__ and __setitem__ (p. 742)
      - Intercepting Slices (p. 743)
      - Intercepting Item Assignments (p. 744)
      - But __index__ Means As-Integer (p. 745)
    - Index Iteration: __getitem__ (p. 745)
    - Iterable Objects: __iter__ and __next__ (p. 746)
      - User-Defined Iterables (p. 747)
      - Multiple Iterators on One Object (p. 749)
      - Coding Alternative: __iter__ Plus yield (p. 752)
    - Membership: __contains__, __iter__, and __getitem__ (p. 756)
    - Attribute Access: __getattr__ and __setattr__ (p. 759)
      - Attribute Reference (p. 759)
      - Attribute Assignment and Deletion (p. 760)
      - Other Attribute-Management Tools (p. 761)
      - Emulating Privacy for Instance Attributes: Part 1 (p. 761)
    - String Representation: __repr__ and __str__ (p. 762)
      - Why Two Display Methods? (p. 763)
    - Display Usage Notes (p. 764)
    - Right-Side and In-Place Ops: __radd__ and __iadd__ (p. 765)
      - Right-Side Addition (p. 766)
      - In-Place Addition (p. 770)
    - Call Expressions: __call__ (p. 770)
      - Function Interfaces and Callback-Based Code (p. 772)
    - Comparisons: __lt__, __gt__, and Others (p. 773)
    - Boolean Tests: __bool__ and __len__ (p. 775)
    - Object Destruction: __del__ (p. 776)
      - Destructor Usage Notes (p. 776)
    - Chapter Summary (p. 777)
    - Test Your Knowledge: Quiz (p. 777)
    - Test Your Knowledge: Answers (p. 778)
  - **31. Designing with Classes** (p. 779)
    - Python and OOP (p. 779)
      - Polymorphism Means Interfaces, Not Call Signatures (p. 780)
    - OOP and Inheritance: “Is-a” Relationships (p. 780)
    - OOP and Composition: “Has-a” Relationships (p. 782)
      - Stream Processors Revisited (p. 784)
    - OOP and Delegation: “Like-a” Relationships (p. 786)
    - Pseudoprivate Class Attributes (p. 788)
      - Name Mangling Overview (p. 789)
      - Why Use Pseudoprivate Attributes? (p. 789)
    - Method Objects: Bound or Not (p. 791)
      - Bound Methods in Action (p. 792)
    - Classes Are Objects: Generic Object Factories (p. 795)
      - Why Factories? (p. 796)
    - Multiple Inheritance and the MRO (p. 796)
      - How Multiple Inheritance Works (p. 797)
      - How the MRO Works (p. 799)
      - Attribute Conflict Resolution (p. 801)
      - Example: “Mix-in” Attribute Listers (p. 802)
      - Example: Mapping Attributes to Inheritance Sources (p. 811)
    - Other Design-Related Topics (p. 815)
    - Chapter Summary (p. 815)
    - Test Your Knowledge: Quiz (p. 815)
    - Test Your Knowledge: Answers (p. 816)
  - **32. Class Odds and Ends** (p. 817)
    - Extending Built-in Object Types (p. 817)
      - Extending Types by Embedding (p. 818)
      - Extending Types by Subclassing (p. 819)
    - The Python Object Model (p. 821)
      - Classes Are Types Are Classes (p. 821)
      - Some Instances Are More Equal Than Others (p. 822)
      - The Inheritance Bifurcation (p. 823)
      - The Metaclass/Class Dichotomy (p. 824)
      - And One “object” to Rule Them All (p. 825)
      - Advanced Attribute Tools (p. 826)
        - Slots: Attribute Declarations (p. 826)
        - Properties: Attribute Accessors (p. 834)
        - __getattribute__ and Descriptors: Attribute Implementations (p. 836)
      - Static and Class Methods (p. 837)
        - Why the Special Methods? (p. 837)
        - Plain-Function Methods (p. 838)
        - Static Method Alternatives (p. 839)
        - Using Static and Class Methods (p. 840)
        - Counting Instances with Static Methods (p. 841)
        - Counting Instances with Class Methods (p. 842)
      - Decorators and Metaclasses (p. 845)
        - Function Decorator Basics (p. 845)
        - A First Look at User-Defined Function Decorators (p. 847)
        - A First Look at Class Decorators and Metaclasses (p. 848)
        - For More Details (p. 850)
      - The super Function (p. 851)
        - The super Basics (p. 851)
        - The super Details (p. 852)
        - The super Wrap-Up (p. 859)
      - Class Gotchas (p. 860)
        - Changing Class Attributes Can Have Side Effects (p. 860)
        - Changing Mutable Class Attributes Can Have Side Effects, Too (p. 861)
        - Multiple Inheritance: Order Matters (p. 862)
        - Scopes in Methods and Classes (p. 863)
        - Miscellaneous Class Gotchas (p. 864)
        - “Overwrapping-itis” (p. 865)
      - Chapter Summary (p. 865)
      - Test Your Knowledge: Quiz (p. 865)
      - Test Your Knowledge: Answers (p. 866)
  - Test Your Knowledge: Part VI Exercises (p. 866)
- **Part VII. Exceptions**
  - **33. Exception Basics** (p. 875)
    - Why Use Exceptions? (p. 875)
      - Exception Roles (p. 876)
    - Exceptions: The Short Story (p. 877)
    - Default Exception Handler (p. 877)
    - Catching Exceptions (p. 878)
    - Raising Exceptions (p. 879)
    - User-Defined Exceptions (p. 880)
    - Termination Actions (p. 881)
    - Chapter Summary (p. 882)
    - Test Your Knowledge: Quiz (p. 883)
    - Test Your Knowledge: Answers (p. 883)
  - **34. Exception Coding Details** (p. 885)
    - The try Statement (p. 885)
      - try Statement Clauses (p. 885)
      - The except and else Clauses (p. 886)
      - The finally Clause (p. 892)
      - Combined try Clauses (p. 894)
    - The raise Statement (p. 898)
      - Raising Exceptions (p. 898)
      - The except as hook (p. 898)
      - Scopes and except as (p. 899)
      - Propagating Exceptions with raise (p. 900)
      - Exception Chaining: raise from (p. 900)
    - The assert Statement (p. 902)
      - Example: Trapping Constraints (but Not Errors!) (p. 903)
    - The with Statement and Context Managers (p. 904)
      - Basic with Usage (p. 904)
      - The Context-Management Protocol (p. 905)
      - Multiple Context Managers (p. 907)
      - The Termination-Handlers Shoot-Out (p. 908)
    - Chapter Summary (p. 909)
    - Test Your Knowledge: Quiz (p. 910)
    - Test Your Knowledge: Answers (p. 910)
  - **35. Exception Objects** (p. 911)
    - Exception Classes (p. 912)
      - Coding Exceptions Classes (p. 912)
      - Why Exception Hierarchies? (p. 914)
    - Built-in Exception Classes (p. 916)
      - Built-in Exception Categories (p. 917)
      - Default Printing and State (p. 918)
    - Custom Print Displays (p. 919)
    - Custom State and Behavior (p. 920)
      - Providing Exception Details (p. 921)
      - Providing Exception Methods (p. 921)
    - Exception Groups: Yet Another Star! (p. 923)
      - Chapter Summary (p. 925)
      - Test Your Knowledge: Quiz (p. 926)
      - Test Your Knowledge: Answers (p. 926)
  - **36. Exception Odds and Ends** (p. 927)
    - Nesting Exception Handlers (p. 927)
      - Example: Control-Flow Nesting (p. 928)
      - Example: Syntactic Nesting (p. 930)
    - Exception Idioms (p. 931)
      - Breaking Out of Multiple Nested Loops: “go to” (p. 931)
      - Exceptions Aren’t Always Errors (p. 932)
      - Functions Can Signal Conditions with raise (p. 933)
      - Closing Files and Server Connections (p. 934)
      - Debugging with Outer try Statements (p. 934)
      - Running In-Process Tests (p. 935)
      - More on sys.exc_info (p. 935)
      - Displaying Errors and Tracebacks (p. 937)
    - Exception Design Tips and Gotchas (p. 938)
      - What Should Be Wrapped (p. 938)
      - Catching Too Much: Avoid Empty except and Exception (p. 938)
      - Catching Too Little: Use Class-Based Categories (p. 940)
    - Core Language Wrap-Up (p. 941)
      - The Python Toolset (p. 941)
      - Development Tools for Larger Projects (p. 941)
    - Chapter Summary (p. 944)
    - Test Your Knowledge: Quiz (p. 945)
    - Test Your Knowledge: Answers (p. 945)
  - Test Your Knowledge: Part VII Exercises (p. 945)
- **Part VIII. Advanced Topics**
  - **37. Unicode and Byte Strings** (p. 949)
    - Unicode Foundations (p. 950)
      - Character Representations (p. 950)
      - Character Encodings (p. 951)
    - Introducing Python String Tools (p. 954)
      - The str Object (p. 954)
      - The bytes Object (p. 954)
      - The bytearray Object (p. 955)
      - Text and Binary Files (p. 955)
    - Using Text Strings (p. 956)
      - Literals and Basic Properties (p. 956)
      - String Type Conversions (p. 957)
    - Coding Unicode Strings in Python (p. 959)
    - Source-File Encoding Declarations (p. 964)
    - Using Byte Strings (p. 966)
      - Methods (p. 966)
      - Sequence Operations (p. 967)
      - Formatting (p. 968)
      - Other Ways to Make Bytes (p. 968)
      - Mixing String Types (p. 969)
      - The bytearray Object (p. 970)
    - Using Text and Binary Files (p. 972)
      - Text-File Basics (p. 973)
      - Text and Binary Modes (p. 973)
      - Unicode-Text Files (p. 975)
    - Unicode, Bytes, and Other String Tools (p. 977)
      - The re Pattern-Matching Module (p. 977)
      - The struct Binary-Data Module (p. 978)
      - The pickle and json Serialization Modules (p. 978)
      - Filenames in open and Other Filename Tools (p. 980)
    - The Unicode Twilight Zone (p. 983)
      - Dropping the BOM in Python (p. 983)
      - Unicode Normalization: Whither Standard? (p. 987)
    - Chapter Summary (p. 989)
    - Test Your Knowledge: Quiz (p. 989)
    - Test Your Knowledge: Answers (p. 989)
  - **38. Managed Attributes** (p. 991)
    - Why Manage Attributes? (p. 991)
      - Inserting Code to Run on Attribute Access (p. 992)
    - Properties (p. 993)
      - The Basics (p. 993)
      - A First Example (p. 994)
      - Computed Attributes (p. 995)
      - Coding Properties with Decorators (p. 996)
    - Descriptors (p. 997)
      - The Basics (p. 998)
      - A First Example (p. 1000)
      - Computed Attributes (p. 1002)
      - Using State Information in Descriptors (p. 1003)
      - How Properties and Descriptors Relate (p. 1006)
    - __getattr__ and __getattribute__ (p. 1007)
      - The Basics (p. 1008)
      - A First Example (p. 1010)
      - Computed Attributes (p. 1012)
      - __getattr__ and __getattribute__ Compared (p. 1014)
        - Management Techniques Compared (p. 1015)
        - Intercepting Built-in Operation Attributes (p. 1017)
        - Example: Attribute Validations (p. 1020)
          - Using Properties to Validate (p. 1021)
          - Using Descriptors to Validate (p. 1023)
          - Using __getattr__ to Validate (p. 1027)
          - Using __getattribute__ to Validate (p. 1028)
        - Chapter Summary (p. 1029)
        - Test Your Knowledge: Quiz (p. 1029)
          - Test Your Knowledge: Answers (p. 1030)
  - **39. Decorators** (p. 1031)
    - What’s a Decorator? (p. 1031)
      - Managing Calls and Instances (p. 1032)
      - Managing Functions and Classes (p. 1032)
      - Using and Defining Decorators (p. 1032)
      - Why Decorators? (p. 1033)
    - The Basics (p. 1034)
      - Function Decorator Basics (p. 1034)
      - Class Decorator Basics (p. 1038)
      - Decorator Nesting (p. 1040)
      - Decorator Arguments (p. 1042)
      - Decorators Manage Functions and Classes, Too (p. 1042)
    - Coding Function Decorators (p. 1043)
      - Tracing Function Calls (p. 1043)
      - Decorator State Retention Options (p. 1044)
      - Class Pitfall: Decorating Methods (p. 1048)
      - Timing Function Calls (p. 1053)
      - Adding Decorator Arguments (p. 1055)
    - Coding Class Decorators (p. 1057)
      - Singleton Classes (p. 1057)
      - Tracing Object Interfaces (p. 1059)
      - Class Pitfall: Retaining Multiple Instances (p. 1062)
    - Example: “Private” and “Public” Attributes (p. 1064)
      - Implementing Private Attributes (p. 1064)
      - Implementation Details I (p. 1066)
      - Generalizing for Public Declarations (p. 1067)
      - Implementation Details II (p. 1070)
      - Delegating Built-In Operations (p. 1070)
    - Example: Validating Function Arguments (p. 1075)
      - The Goal (p. 1076)
      - A Basic Range-Testing Decorator for Positional Arguments (p. 1076)
      - Generalizing for Keywords and Defaults (p. 1078)
      - Implementation Details (p. 1082)
    - Open Issues (p. 1083)
    - Decorator Arguments Versus Function Annotations (p. 1085)
    - Chapter Summary (p. 1087)
    - Test Your Knowledge: Quiz (p. 1087)
    - Test Your Knowledge: Answers (p. 1088)
  - **40. Metaclasses and Inheritance** (p. 1089)
    - To Metaclass or Not to Metaclass (p. 1090)
      - The Downside of “Helper” Functions (p. 1090)
      - Metaclasses Versus Class Decorators: Round 1 (p. 1092)
    - The Metaclass Model (p. 1093)
      - Classes Are Instances of type (p. 1093)
      - Metaclasses Are Subclasses of type (p. 1094)
      - Class Statements Call a type (p. 1095)
      - Class Statements Can Choose a type (p. 1096)
      - Metaclass Method Protocol (p. 1097)
    - Coding Metaclasses (p. 1097)
      - A Basic Metaclass (p. 1097)
      - Customizing Construction and Initialization (p. 1099)
      - Other Metaclass Coding Techniques (p. 1100)
      - Managing Classes with Metaclasses and Decorators (p. 1103)
    - Inheritance: The Finale (p. 1108)
      - Metaclass Versus Superclass (p. 1110)
      - Metaclass Inheritance (p. 1111)
      - Python Inheritance Algorithm: The Simple Version (p. 1112)
      - Python Inheritance Algorithm: The Less Simple Version (p. 1115)
      - The Inheritance Wrap-Up (p. 1117)
    - Metaclass Methods (p. 1118)
      - Metaclass Methods Versus Class Methods (p. 1119)
      - Operator Overloading in Metaclass Methods (p. 1120)
      - Metaclass Methods Versus Instance Methods (p. 1120)
    - Chapter Summary (p. 1122)
    - Test Your Knowledge: Quiz (p. 1122)
    - Test Your Knowledge: Answers (p. 1123)
  - **41. All Good Things** (p. 1125)
    - The Python Tsunami (p. 1125)
    - The Python Sandbox (p. 1127)
    - The Python Upside (p. 1127)
    - Closing Thoughts (p. 1128)
    - Where to Go from Here (p. 1128)
    - Encore: Print Your Own Completion Certificate! (p. 1128)
- **Part IX. Appendixes**
  - **A. Platform Usage Tips** (p. 1135)
  - **B. Solutions to End-of-Part Exercises** (p. 1157)
  - Index (p. 1197)
